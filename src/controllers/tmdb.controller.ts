import admin, { db } from "../config/firebase.config.js";
import Scraper from "../data/scrape.js";
import { ApiError } from "../utils/ApiError.utils.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import type { Request, Response } from "express";
import cron from "node-cron";

// Trending Movies Interfaces
interface IMDBTrendingResponse {
  title: string;
  movieUrl: string;
  watchlistId: string;
  year: string;
  posterUrl: string;
  posterAlt: string;
  metascore: string;
  imdbVotes: string;
  imdbRating: string;
  rating: string;
  runtime: string;
  ranking: string;
  plot: string;
  director: string;
  stars: string[];
}

interface CachedTrendingMovies {
  data: IMDBTrendingResponse[];
  cached_at: admin.firestore.Timestamp;
  expires_at: admin.firestore.Timestamp;
  auto_generated: boolean;
}

// TMDB Videos Interfaces
interface TMDBVideo {
  iso_639_1: string;
  iso_3166_1: string;
  name: string;
  key: string;
  site: string;
  size: number;
  type: string;
  official: boolean;
  published_at: string;
  id: string;
}

interface TMDBVideosResponse {
  id: number;
  results: TMDBVideo[];
}

interface CachedMovieVideos {
  movie_id: string;
  data: TMDBVideo[];
  cached_at: admin.firestore.Timestamp;
  expires_at: admin.firestore.Timestamp;
}

// TMDB API configuration
const TMDB_BASE_URL = "https://api.themoviedb.org/3";
const TMDB_BEARER_TOKEN =
  "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJlM2UxOTUyNDgyZjEyZmQ0NWQ5ODI1MGFmMTZiNGE1MiIsIm5iZiI6MTc1NDMwNjA5MS44NDcwMDAxLCJzdWIiOiI2ODkwOTYyYmUwMzQyYmE4ODNiN2Y0ZDgiLCJzY29wZXMiOlsiYXBpX3JlYWQiXSwidmVyc2lvbiI6MX0.LhSUvrLpYh2Y93odopy8Yqe4JYacf0bBP9ouypSTH80";

// ===========================================
// TRENDING MOVIES FUNCTIONS
// ===========================================

const isCacheExpired = (cachedAt: admin.firestore.Timestamp): boolean => {
  const now = new Date();
  const cacheTime = cachedAt.toDate();
  const twentyFourHoursAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);

  return cacheTime < twentyFourHoursAgo;
};

const fetchTrendingMoviesFromAPI = async (): Promise<
  IMDBTrendingResponse[]
> => {
  try {
    const scraper = new Scraper();
    const movieList = await scraper.scrapeTrending(
      "https://www.imdb.com/list/ls082250769/"
    );

    const data = movieList as IMDBTrendingResponse[];

    if (!Array.isArray(data) || data.length === 0) {
      throw new ApiError(500, "No trending movies data received");
    }

    return data;
  } catch (error) {
    console.error("Error fetching trending movies:", error);
    throw new ApiError(500, "Failed to fetch trending movies");
  }
};

const storeTrendingMoviesInCache = async (
  data: IMDBTrendingResponse[],
  autoGenerated = false
): Promise<void> => {
  try {
    const now = admin.firestore.Timestamp.now();
    const expiresAt = admin.firestore.Timestamp.fromDate(
      new Date(Date.now() + 24 * 60 * 60 * 1000)
    );

    const cacheData: CachedTrendingMovies = {
      data,
      cached_at: now,
      expires_at: expiresAt,
      auto_generated: autoGenerated,
    };

    await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .set(cacheData);

    console.log(
      `üé¨ Stored trending movies in cache (${
        autoGenerated ? "auto-generated" : "manual"
      }):`,
      new Date().toISOString(),
      `- Total movies: ${data.length}`
    );
  } catch (error) {
    console.error("Error storing cache:", error);
    throw new ApiError(500, "Failed to store cache");
  }
};

const GetTrendingMovies = asyncHandler(async (req: Request, res: Response) => {
  try {
    const cacheDoc = await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .get();

    if (cacheDoc.exists) {
      const cachedData = cacheDoc.data() as CachedTrendingMovies;

      if (!isCacheExpired(cachedData.cached_at)) {
        console.log("üìã Retrieved trending movies from cache");

        return res.status(200).json({
          success: true,
          data: cachedData.data,
          source: "cache",
          cached_at: cachedData.cached_at.toDate(),
          expires_at: cachedData.expires_at.toDate(),
          total_movies: cachedData.data.length,
        });
      } else {
        console.log("Cache expired, fetching fresh data...");
      }
    }

    console.log("Fetching trending movies from IMDb...");
    const trendingData = await fetchTrendingMoviesFromAPI();
    await storeTrendingMoviesInCache(trendingData, false);

    res.status(200).json({
      success: true,
      data: trendingData,
      source: "api",
      cached_at: new Date(),
      expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000),
      total_movies: trendingData.length,
    });
  } catch (error: any) {
    console.error("‚ùå Error getting trending movies:", error);

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get trending movies",
        type: "INTERNAL_ERROR",
      });
    }
  }
});

const RefreshTrendingMovies = asyncHandler(
  async (req: Request, res: Response) => {
    try {
      console.log("üîÑ Manually refreshing trending movies...");

      const trendingData = await fetchTrendingMoviesFromAPI();
      await storeTrendingMoviesInCache(trendingData, false);

      res.status(200).json({
        success: true,
        message: "Trending movies refreshed successfully",
        data: trendingData,
        refreshed_at: new Date(),
        total_movies: trendingData.length,
      });
    } catch (error: any) {
      console.error("‚ùå Error refreshing trending movies:", error);

      if (error instanceof ApiError) {
        res.status(error.statusCode).json({
          success: false,
          status: error.statusCode,
          message: error.message,
          type: error.type,
        });
      } else {
        res.status(500).json({
          success: false,
          status: 500,
          message: "Failed to refresh trending movies",
          type: "INTERNAL_ERROR",
        });
      }
    }
  }
);

const cleanupExpiredCache = async (): Promise<void> => {
  try {
    const cacheDoc = await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .get();

    if (cacheDoc.exists) {
      const cachedData = cacheDoc.data() as CachedTrendingMovies;

      if (isCacheExpired(cachedData.cached_at)) {
        await cacheDoc.ref.delete();
        console.log("üóëÔ∏è Deleted expired trending movies cache");

        await autoRefreshTrendingMovies();
      } else {
        console.log("‚úÖ Trending movies cache is still valid");
      }
    } else {
      console.log("üì≠ No trending movies cache found, triggering auto-refresh");
      await autoRefreshTrendingMovies();
    }
  } catch (error) {
    console.error("‚ùå Error cleaning up expired cache:", error);
  }
};

const autoRefreshTrendingMovies = async (): Promise<void> => {
  try {
    const cacheDoc = await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .get();

    let shouldRefresh = true;

    if (cacheDoc.exists) {
      const cachedData = cacheDoc.data() as CachedTrendingMovies;
      shouldRefresh = isCacheExpired(cachedData.cached_at);
    }

    if (shouldRefresh) {
      const trendingData = await fetchTrendingMoviesFromAPI();
      await storeTrendingMoviesInCache(trendingData, true);
      console.log("üöÄ Auto-refresh completed successfully");
    } else {
      console.log("‚è≠Ô∏è Skip auto-refresh: cache is still valid");
    }
  } catch (error) {
    console.error("‚ùå Error in auto-refresh:", error);
  }
};

const GetCacheStatus = asyncHandler(async (req: Request, res: Response) => {
  try {
    const cacheDoc = await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .get();

    if (!cacheDoc.exists) {
      return res.status(200).json({
        success: true,
        cache_exists: false,
        message: "No cache found",
      });
    }

    const cachedData = cacheDoc.data() as CachedTrendingMovies;
    const isExpired = isCacheExpired(cachedData.cached_at);
    const timeLeft = cachedData.expires_at.toDate().getTime() - Date.now();

    res.status(200).json({
      success: true,
      cache_exists: true,
      is_expired: isExpired,
      cached_at: cachedData.cached_at.toDate(),
      expires_at: cachedData.expires_at.toDate(),
      time_left_ms: Math.max(0, timeLeft),
      time_left_hours: Math.max(0, Math.round(timeLeft / (1000 * 60 * 60))),
      auto_generated: cachedData.auto_generated,
      total_movies: cachedData.data.length,
    });
  } catch (error: any) {
    console.error("‚ùå Error getting cache status:", error);

    res.status(500).json({
      success: false,
      status: 500,
      message: "Failed to get cache status",
      type: "INTERNAL_ERROR",
    });
  }
});

// ===========================================
// VIDEOS FUNCTIONS
// ===========================================

// Cache expiration check (1 hour for videos)
const isVideoCacheExpired = (cachedAt: admin.firestore.Timestamp): boolean => {
  const now = new Date();
  const cacheTime = cachedAt.toDate();
  const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);

  return cacheTime < oneHourAgo;
};

// Fetch videos from TMDB API
const fetchMovieVideosFromAPI = async (
  movieId: string
): Promise<TMDBVideo[]> => {
  try {
    const url = `${TMDB_BASE_URL}/movie/${movieId}/videos?language=en-US`;
    const options = {
      method: "GET",
      headers: {
        accept: "application/json",
        Authorization: `Bearer ${TMDB_BEARER_TOKEN}`,
      },
    };

    const response = await fetch(url, options);

    if (!response.ok) {
      throw new ApiError(
        response.status,
        `TMDB API error: ${response.statusText}`
      );
    }

    const data = (await response.json()) as TMDBVideosResponse;

    if (!data.results || !Array.isArray(data.results)) {
      throw new ApiError(500, "Invalid response format from TMDB API");
    }

    return data.results;
  } catch (error) {
    console.error("Error fetching movie videos:", error);
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, "Failed to fetch movie videos from TMDB");
  }
};

// Store videos in cache
const storeVideosInCache = async (
  movieId: string,
  videos: TMDBVideo[]
): Promise<void> => {
  try {
    const now = admin.firestore.Timestamp.now();
    const expiresAt = admin.firestore.Timestamp.fromDate(
      new Date(Date.now() + 60 * 60 * 1000) // 1 hour cache
    );

    const cacheData: CachedMovieVideos = {
      movie_id: movieId,
      data: videos,
      cached_at: now,
      expires_at: expiresAt,
    };

    await db
      .collection("movie_videos_cache")
      .doc(`movie_${movieId}`)
      .set(cacheData);

    console.log(
      `üìπ Stored videos for movie ${movieId} in cache:`,
      new Date().toISOString()
    );
  } catch (error) {
    console.error("Error storing video cache:", error);
    throw new ApiError(500, "Failed to store video cache");
  }
};

const GetMovieVideos = asyncHandler(async (req: Request, res: Response) => {
  try {
    const movieIdParam = req.params.movieId;
    if (!movieIdParam) {
      throw new ApiError(400, "Movie ID parameter is required");
    }
    console.log(movieIdParam);

    if (!movieIdParam) {
      throw new ApiError(400, "Valid movie ID is required");
    }

    const cacheDoc = await db
      .collection("movie_videos_cache")
      .doc(`movie_${movieIdParam}`)
      .get();

    if (cacheDoc.exists) {
      const cachedData = cacheDoc.data() as CachedMovieVideos;

      if (!isVideoCacheExpired(cachedData.cached_at)) {
        console.log(`üìã Retrieved videos for movie ${movieIdParam} from cache`);

        return res.status(200).json({
          success: true,
          movie_id: movieIdParam,
          data: cachedData.data,
          source: "cache",
          cached_at: cachedData.cached_at.toDate(),
          expires_at: cachedData.expires_at.toDate(),
          total_videos: cachedData.data.length,
        });
      } else {
        console.log(
          `üîÑ Cache expired for movie ${movieIdParam}, fetching fresh data...`
        );
      }
    }

    console.log(`üé¨ Fetching videos for movie ${movieIdParam} from TMDB...`);
    const videos = await fetchMovieVideosFromAPI(movieIdParam);

    await storeVideosInCache(movieIdParam, videos);

    res.status(200).json({
      success: true,
      movie_id: movieIdParam,
      data: videos,
      source: "api",
      cached_at: new Date(),
      expires_at: new Date(Date.now() + 60 * 60 * 1000),
      total_videos: videos.length,
    });
  } catch (error: any) {
    console.error(
      `‚ùå Error getting videos for movie ${req.params.movieId || "unknown"}:`,
      error
    );

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get movie videos",
        type: "INTERNAL_ERROR",
      });
    }
  }
});

// Clear video cache for a specific movie
const ClearMovieVideoCache = asyncHandler(
  async (req: Request, res: Response) => {
    try {
      const movieIdParam = req.params.movieId;
      if (!movieIdParam) {
        throw new ApiError(400, "Movie ID parameter is required");
      }

      const movieId = parseInt(movieIdParam);

      if (!movieId || isNaN(movieId)) {
        throw new ApiError(400, "Valid movie ID is required");
      }

      await db
        .collection("movie_videos_cache")
        .doc(`movie_${movieId}`)
        .delete();

      res.status(200).json({
        success: true,
        message: `Video cache cleared for movie ${movieId}`,
        movie_id: movieId,
      });
    } catch (error: any) {
      console.error(
        `‚ùå Error clearing video cache for movie ${
          req.params.movieId || "unknown"
        }:`,
        error
      );

      if (error instanceof ApiError) {
        res.status(error.statusCode).json({
          success: false,
          status: error.statusCode,
          message: error.message,
          type: error.type,
        });
      } else {
        res.status(500).json({
          success: false,
          status: 500,
          message: "Failed to clear video cache",
          type: "INTERNAL_ERROR",
        });
      }
    }
  }
);

// Get video cache status for a specific movie
const GetMovieVideoCacheStatus = asyncHandler(
  async (req: Request, res: Response) => {
    try {
      const movieIdParam = req.params.movieId;
      if (!movieIdParam) {
        throw new ApiError(400, "Movie ID parameter is required");
      }

      const movieId = parseInt(movieIdParam);

      if (!movieId || isNaN(movieId)) {
        throw new ApiError(400, "Valid movie ID is required");
      }

      const cacheDoc = await db
        .collection("movie_videos_cache")
        .doc(`movie_${movieId}`)
        .get();

      if (!cacheDoc.exists) {
        return res.status(200).json({
          success: true,
          movie_id: movieId,
          cache_exists: false,
          message: "No cache found for this movie",
        });
      }

      const cachedData = cacheDoc.data() as CachedMovieVideos;
      const isExpired = isVideoCacheExpired(cachedData.cached_at);
      const timeLeft = cachedData.expires_at.toDate().getTime() - Date.now();

      res.status(200).json({
        success: true,
        movie_id: movieId,
        cache_exists: true,
        is_expired: isExpired,
        cached_at: cachedData.cached_at.toDate(),
        expires_at: cachedData.expires_at.toDate(),
        time_left_ms: Math.max(0, timeLeft),
        time_left_minutes: Math.max(0, Math.round(timeLeft / (1000 * 60))),
        total_videos: cachedData.data.length,
      });
    } catch (error: any) {
      console.error(
        `‚ùå Error getting video cache status for movie ${
          req.params.movieId || "unknown"
        }:`,
        error
      );

      if (error instanceof ApiError) {
        res.status(error.statusCode).json({
          success: false,
          status: error.statusCode,
          message: error.message,
          type: error.type,
        });
      } else {
        res.status(500).json({
          success: false,
          status: 500,
          message: "Failed to get video cache status",
          type: "INTERNAL_ERROR",
        });
      }
    }
  }
);

const getTMDbFromIMDb = async (req: Request, res: Response) => {
  try {
    const imdbId = req.query.imdbId;
    console.log(imdbId);

    const url = `${TMDB_BASE_URL}/find/${imdbId}?external_source=imdb_id`;
    console.log(url);
    const response = await fetch(url, {
      method: "GET",
      headers: {
        accept: "application/json",
        Authorization: `Bearer ${TMDB_BEARER_TOKEN}`,
      },
    });

    if (!response.ok) {
      return res.status(response.status).json({
        success: false,
        message: `TMDb API error: ${response.statusText}`,
      });
    }

    const data = await response.json();
    console.log(data);
    return res.status(200).json({
      success: true,
      imdb_id: imdbId,
      //@ts-ignore
      tmdb_results: data?.movie_results || [],
    });
  } catch (error: any) {
    console.error("Error fetching TMDb data:", error);
    return res.status(500).json({
      success: false,
      message: "Internal Server Error",
    });
  }
};
// Cleanup expired video caches (utility function)
const cleanupExpiredVideoCache = async (): Promise<void> => {
  try {
    const videoCacheCollection = db.collection("movie_videos_cache");
    const snapshot = await videoCacheCollection.get();

    const deletePromises: Promise<any>[] = [];

    snapshot.forEach((doc) => {
      const cachedData = doc.data() as CachedMovieVideos;
      if (isVideoCacheExpired(cachedData.cached_at)) {
        console.log(
          `üóëÔ∏è Deleting expired video cache for movie ${cachedData.movie_id}`
        );
        deletePromises.push(doc.ref.delete());
      }
    });

    if (deletePromises.length > 0) {
      await Promise.all(deletePromises);
      console.log(
        `‚úÖ Cleaned up ${deletePromises.length} expired video cache entries`
      );
    } else {
      console.log("‚ú® No expired video cache entries found");
    }
  } catch (error) {
    console.error("‚ùå Error cleaning up expired video cache:", error);
  }
};

// ===========================================
// CRON JOBS INITIALIZATION
// ===========================================

const initializeCronJobs = (): void => {
  // Auto refresh trending movies every 6 hours
  cron.schedule("0 */6 * * *", autoRefreshTrendingMovies, {
    timezone: "Asia/Kolkata",
  });

  // Cleanup expired trending cache every hour
  cron.schedule("0 * * * *", cleanupExpiredCache, {
    timezone: "Asia/Kolkata",
  });

  // Daily refresh at midnight
  cron.schedule("1 0 * * *", autoRefreshTrendingMovies, {
    timezone: "Asia/Kolkata",
  });

  // Cleanup expired video caches every 2 hours
  cron.schedule("0 */2 * * *", cleanupExpiredVideoCache, {
    timezone: "Asia/Kolkata",
  });

  console.log("üöÄ Cron jobs initialized:");
  console.log("  - Trending movies auto-refresh: Every 6 hours");
  console.log("  - Trending cache cleanup: Every hour");
  console.log("  - Daily trending refresh: Midnight");
  console.log("  - Video cache cleanup: Every 2 hours");
};

// Initialize cron jobs when module loads
initializeCronJobs();

// ===========================================
// EXPORTS
// ===========================================

export {
  GetTrendingMovies,
  RefreshTrendingMovies,
  GetCacheStatus,
  GetMovieVideos,
  ClearMovieVideoCache,
  GetMovieVideoCacheStatus,
  initializeCronJobs,
  cleanupExpiredCache,
  autoRefreshTrendingMovies,
  fetchMovieVideosFromAPI,
  storeVideosInCache,
  cleanupExpiredVideoCache,
  isVideoCacheExpired,
  getTMDbFromIMDb,
};
