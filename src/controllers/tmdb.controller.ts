import admin, { db } from "../config/firebase.config.js";
import Scraper from "../data/scrape.js";
import { ApiError } from "../utils/ApiError.utils.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import type { Request, Response } from "express";
import {
  GetMovieByTitleFunction,
  isOMDbError,
  type OMDbDetailResponse,
} from "./omdb.controller.js";
import { getRecommendationsFromML } from "./user.controller.js";

interface IMDBTrendingResponse {
  title: string;
  movieUrl: string;
  watchlistId: string;
  year: string;
  posterUrl: string;
  posterAlt: string;
  metascore: string;
  imdbVotes: string;
  imdbRating: string;
  rating: string;
  runtime: string;
  ranking: string;
  plot: string;
  director: string;
  stars: string[];
  imdbId: string; // Add this field
}

interface CachedTrendingMovies {
  data: IMDBTrendingResponse[];
  cached_at: admin.firestore.Timestamp;
  auto_generated: boolean;
}

const fetchTrendingMoviesFromAPI = async (): Promise<
  IMDBTrendingResponse[]
> => {
  const scraper = new Scraper();

  try {
    console.log("üé¨ Starting to scrape trending movies from IMDb...");

    const movieList = await scraper.scrapeTrending(
      "https://www.imdb.com/list/ls082250769/"
    );

    console.log("üìä Raw scraper result:", {
      type: typeof movieList,
      isArray: Array.isArray(movieList),
      length: Array.isArray(movieList) ? movieList.length : "N/A",
    });

    // Enhanced validation and error handling
    if (!movieList) {
      console.error("‚ùå Scraper returned null/undefined");
      throw new ApiError(500, "Scraper returned no data");
    }

    if (!Array.isArray(movieList)) {
      console.error("‚ùå Scraper returned non-array data:", typeof movieList);
      throw new ApiError(500, "Scraper returned invalid data format");
    }

    if (movieList.length === 0) {
      console.error("‚ùå Scraper returned empty array");
      throw new ApiError(500, "No trending movies found on IMDb");
    }

    // Filter out invalid entries
    const validMovies = movieList.filter((movie) => {
      const isValid =
        movie &&
        typeof movie === "object" &&
        movie.title &&
        movie.title.trim() !== "";

      if (!isValid) {
        console.warn("‚ö†Ô∏è Filtered out invalid movie:", movie);
      }

      return isValid;
    });

    console.log(`‚úÖ Successfully scraped ${validMovies.length} valid movies`);

    if (validMovies.length === 0) {
      throw new ApiError(500, "No valid trending movies data found");
    }

    return validMovies as IMDBTrendingResponse[];
  } catch (error) {
    console.error("‚ùå Error in fetchTrendingMoviesFromAPI:", error);

    // Re-throw ApiErrors as-is
    if (error instanceof ApiError) {
      throw error;
    }

    // Handle network/timeout errors
    if (error instanceof Error) {
      if (
        error.message.includes("timeout") ||
        error.message.includes("navigation")
      ) {
        throw new ApiError(504, "IMDb scraping timeout - please try again");
      }
      if (error.message.includes("net::")) {
        throw new ApiError(503, "Network error while accessing IMDb");
      }
    }

    // Generic error fallback
    throw new ApiError(
      500,
      `Failed to fetch trending movies: ${
        error instanceof Error ? error.message : "Unknown error"
      }`
    );
  } finally {
    // Ensure browser is always closed
    try {
      await scraper.close();
      console.log("üîí Browser closed successfully");
    } catch (closeError) {
      console.error("‚ö†Ô∏è Error closing browser:", closeError);
    }
  }
};

const storeTrendingMoviesInCache = async (
  data: IMDBTrendingResponse[],
  autoGenerated = false
): Promise<void> => {
  try {
    const now = admin.firestore.Timestamp.now();

    const cacheData: CachedTrendingMovies = {
      data,
      cached_at: now,
      auto_generated: autoGenerated,
    };

    await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .set(cacheData);

    console.log(
      `‚úÖ Stored trending movies in cache (${
        autoGenerated ? "auto-generated" : "manual"
      }):`,
      new Date().toISOString(),
      `- Total movies: ${data.length}`
    );
  } catch (error) {
    console.error("‚ùå Error storing cache:", error);
    throw new ApiError(500, "Failed to store cache");
  }
};

const GetTrendingMovies = asyncHandler(async (req: Request, res: Response) => {
  try {
    const cacheDoc = await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .get();

    if (cacheDoc.exists) {
      const cachedData = cacheDoc.data() as CachedTrendingMovies;
      const cacheAge = Date.now() - cachedData.cached_at.toMillis();
      const cacheAgeHours = cacheAge / (1000 * 60 * 60);

      if (cacheAgeHours < 6) {
        console.log(
          `üìã Returning cached data (${cacheAgeHours.toFixed(1)} hours old)`
        );
        return res.status(200).json({
          success: true,
          data: cachedData.data,
          source: "cache",
          cached_at: cachedData.cached_at.toDate(),
          cache_age_hours: Math.round(cacheAgeHours * 10) / 10,
          total_movies: cachedData.data.length,
        });
      } else {
        console.log(
          `‚è∞ Cache is ${cacheAgeHours.toFixed(1)} hours old, refreshing...`
        );
      }
    }

    console.log("üîÑ Fetching fresh trending movies from IMDb...");

    const trendingData = await fetchTrendingMoviesFromAPI();
    await storeTrendingMoviesInCache(trendingData, false);

    res.status(200).json({
      success: true,
      data: trendingData,
      source: "fresh_scrape",
      cached_at: new Date(),
      total_movies: trendingData.length,
    });
  } catch (error: any) {
    console.error("‚ùå Error in GetTrendingMovies:", error);

    if (error instanceof ApiError) {
      // Try to return stale cache as fallback
      try {
        const cacheDoc = await db
          .collection("trending_movies_cache")
          .doc("daily_trending")
          .get();

        if (cacheDoc.exists) {
          const cachedData = cacheDoc.data() as CachedTrendingMovies;
          console.log("üîÑ Returning stale cache as fallback");

          return res.status(200).json({
            success: true,
            data: cachedData.data,
            source: "stale_cache_fallback",
            cached_at: cachedData.cached_at.toDate(),
            total_movies: cachedData.data.length,
            warning: "Fresh data unavailable, using cached data",
          });
        }
      } catch (cacheError) {
        console.error("‚ùå Cache fallback also failed:", cacheError);
      }

      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get trending movies",
        type: "INTERNAL_ERROR",
      });
    }
  }
});

const fetchMovieFromIMDb = async (imdbId: string): Promise<any> => {
  const scraper = new Scraper();

  try {
    const movieData = await scraper.scrapeCompleteMovieData(
      `https://www.imdb.com/title/${imdbId}`
    );

    if (!movieData) {
      throw new ApiError(404, "Movie not found or failed to scrape");
    }

    console.log(`‚úÖ Successfully scraped data for ${imdbId}`);
    return movieData;
  } catch (error) {
    console.error(`‚ùå Error scraping movie data for ${imdbId}:`, error);

    if (error instanceof ApiError) {
      throw error;
    }

    throw new ApiError(500, "Failed to scrape movie data from IMDb");
  } finally {
    try {
      await scraper.close();
    } catch (closeError) {
      console.error("‚ö†Ô∏è Error closing scraper:", closeError);
    }
  }
};

const storeMovieDataInFirebase = async (
  imdbId: string,
  movieData: any
): Promise<void> => {
  try {
    // Recursively remove undefined values from the entire movieData object
    const sanitizeObject = (obj: any): any => {
      if (obj === null || obj === undefined) {
        return null;
      }

      if (Array.isArray(obj)) {
        return obj.map(sanitizeObject);
      }

      if (typeof obj === "object") {
        const sanitized: any = {};
        for (const [key, value] of Object.entries(obj)) {
          if (value !== undefined) {
            sanitized[key] = sanitizeObject(value);
          }
        }
        return sanitized;
      }

      return obj;
    };

    const sanitizedMovieData = sanitizeObject(movieData);

    const movieDoc = {
      imdb_id: imdbId,
      data: sanitizedMovieData,
      created_at: admin.firestore.Timestamp.now(),
      updated_at: admin.firestore.Timestamp.now(),
    };

    await db.collection("movies").doc(imdbId).set(movieDoc);

    console.log(`‚úÖ Stored movie data for ${imdbId} in Firebase`);
  } catch (error) {
    console.error(`‚ùå Error storing movie data for ${imdbId}:`, error);
    throw new ApiError(500, "Failed to store movie data in Firebase");
  }
};

const isVideoSourceExpired = (videoSources: any[]): boolean => {
  if (!videoSources || videoSources.length === 0) return true;

  const currentTime = Math.floor(Date.now() / 1000);

  for (const source of videoSources) {
    if (source.src) {
      const expiresMatch = source.src.match(/Expires=(\d+)/);
      if (expiresMatch) {
        const expirationTime = parseInt(expiresMatch[1]);
        if (expirationTime <= currentTime + 3600) {
          console.log(`‚è∞ Video source expired: ${source.src}`);
          return true;
        }
      }
    }
  }

  return false;
};

const updateVideoSources = async (imdbId: string, movieData: any) => {
  const scraper = new Scraper();

  try {
    const imdbUrl = `https://www.imdb.com/title/${imdbId}/`;
    await scraper.start(imdbUrl);

    const newVideoSources = await scraper.scrapeVideoSources();

    movieData.videoSources = newVideoSources;
    movieData.videoSourcesUpdatedAt = new Date().toISOString();

    await storeMovieDataInFirebase(imdbId, movieData);

    console.log(`‚úÖ Updated video sources for ${imdbId}`);
    return newVideoSources;
  } catch (error) {
    console.error(`‚ùå Failed to update video sources for ${imdbId}:`, error);
    return movieData.videoSources;
  } finally {
    try {
      await scraper.close();
    } catch (closeError) {
      console.error("‚ö†Ô∏è Error closing scraper:", closeError);
    }
  }
};

const GetMovieData = asyncHandler(async (req: Request, res: Response) => {
  try {
    const imdbIdParam = req.params.imdbId;
    if (!imdbIdParam) {
      throw new ApiError(400, "IMDb ID parameter is required");
    }

    const movieDoc = await db.collection("movies").doc(imdbIdParam).get();

    if (movieDoc.exists) {
      const movieData = movieDoc.data();
      console.log(`üìã Retrieved movie data for ${imdbIdParam} from Firebase`);

      const videoSources = movieData?.data?.videoSources;

      if (videoSources && isVideoSourceExpired(videoSources)) {
        console.log(`üîÑ Video sources expired for ${imdbIdParam}, updating...`);

        const updatedVideoSources = await updateVideoSources(
          imdbIdParam,
          movieData.data
        );
        movieData.data.videoSources = updatedVideoSources;
      }

      return res.status(200).json({
        success: true,
        imdb_id: imdbIdParam,
        data: movieData?.data,
        source:
          videoSources && isVideoSourceExpired(videoSources)
            ? "firebase_updated"
            : "firebase",
      });
    }

    const apiKey = process.env.OMDB_API_KEY;
    const url = `https://www.omdbapi.com/?i=${imdbIdParam}&apikey=${apiKey}`;

    const movieData = await fetchMovieFromIMDb(imdbIdParam);
    const response = await fetch(url);
    const data = (await response.json()) as OMDbDetailResponse;

    if (isOMDbError(data)) {
      throw new ApiError(404, data.Error, "NOT_FOUND");
    }

    const sanitizeValue = (value: any) => (value === undefined ? null : value);

    const omdbRating = sanitizeValue(data.Ratings);
    const storyLine = sanitizeValue(data.Plot);
    const genre = sanitizeValue(data.Genre);
    const BoxOffice = sanitizeValue(data.BoxOffice);
    const Language = sanitizeValue(data.Language);
    const title = sanitizeValue(data.Title);
    const Released = sanitizeValue(data.Released);
    const Runtime = sanitizeValue(data.Runtime);
    const Awards = sanitizeValue(data.Awards);
    const Director = sanitizeValue(data.Director);
    const Rated = sanitizeValue(data.Rated);
    const Country = sanitizeValue(data.Country);

    movieData.Country = Country;
    movieData.Director = Director;
    movieData.Released = Released;
    movieData.Runtime = Runtime;
    movieData.Awards = Awards;
    movieData.Language = Language;
    movieData.storyLine = storyLine;
    movieData.rating = omdbRating;
    movieData.genre = genre;
    movieData.BoxOffice = BoxOffice;
    movieData.title = title;
    movieData.Rated = Rated;

    await storeMovieDataInFirebase(imdbIdParam, movieData);

    res.status(200).json({
      success: true,
      imdb_id: imdbIdParam,
      data: movieData,
      source: "fresh_scrape",
    });
  } catch (error: any) {
    console.error(
      `‚ùå Error getting movie data for ${req.params.imdbId}:`,
      error
    );

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get movie data",
      });
    }
  }
});

const saveCommentToMovie = async (
  imdbId: string,
  commentData: {
    movieTitle: string;
    poster: string;
    imdb_id: string;
    userId: string;
    userDisplayName: string;
    userPhotoURL?: string;
    comment: string;
    rating?: number;
    title: string;
  }
): Promise<void> => {
  try {
    const commentId = `${commentData.userId}_${imdbId}`;
    const timestamp = new Date().toISOString();

    const movieComment = {
      id: commentId,
      movieTitle: commentData.movieTitle,
      poster: commentData.poster,
      userId: commentData.userId,
      userDisplayName: commentData.userDisplayName,
      userPhotoURL: commentData.userPhotoURL,
      comment: commentData.comment,
      rating: commentData.rating,
      title: commentData.title,
      imdb_id: commentData.imdb_id,
      timestamp,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    };

    await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .doc(commentId)
      .set(movieComment, { merge: true });

    console.log(`‚úÖ Comment saved for movie ${imdbId}`);
  } catch (error) {
    console.error("‚ùå Error saving comment to movie:", error);
    throw new ApiError(500, "Failed to save comment to movie");
  }
};

const deleteCommentFromMovie = async (
  imdbId: string,
  userId: string
): Promise<void> => {
  try {
    const commentId = `${userId}_${imdbId}`;

    const commentDoc = await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .doc(commentId)
      .get();

    if (!commentDoc.exists) {
      console.log(`‚ÑπÔ∏è Comment ${commentId} not found in movie ${imdbId}`);
      return;
    }

    await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .doc(commentId)
      .delete();

    console.log(`‚úÖ Comment deleted from movie ${imdbId}`);
  } catch (error) {
    console.error("‚ùå Error deleting comment from movie:", error);
    throw new ApiError(500, "Failed to delete comment from movie");
  }
};

const GetMovieReviews = asyncHandler(async (req: Request, res: Response) => {
  try {
    const { imdbId } = req.params;

    if (!imdbId) {
      throw new ApiError(400, "IMDb ID is required", "BAD_REQUEST");
    }

    const reviewsSnapshot = await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .orderBy("timestamp", "desc")
      .get();

    const reviews = reviewsSnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));

    res.status(200).json({
      success: true,
      data: reviews,
      total_reviews: reviews.length,
      imdb_id: imdbId,
    });
  } catch (error: any) {
    console.error("‚ùå Error getting movie reviews:", error);

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get movie reviews",
        type: "INTERNAL_ERROR",
      });
    }
  }
});

const getSimilarMovies = asyncHandler(async (req: Request, res: Response) => {
  try {
    const { title } = req.params;
    //@ts-ignore
    const userId = req.user?.uid;

    console.log(`üîç Getting similar movies for: ${title}`);

    if (!title || title.trim() === "") {
      throw new ApiError(400, "Title parameter is required", "BAD_REQUEST");
    }

    const detailedMovies = [];
    const similarMovies = await getRecommendationsFromML(title);

    for (const movie of similarMovies) {
      try {
        const detailMovie = await GetMovieByTitleFunction(userId, movie);
        //@ts-ignore
        detailedMovies.push(detailMovie);
      } catch (error) {
        console.warn(
          `‚ö†Ô∏è Failed to get details for similar movie: ${movie}`,
          error
        );
        // Continue with other movies instead of failing completely
      }
    }

    res.status(200).json({
      success: true,
      message: "Similar movies processed successfully",
      similarMoviesCount: detailedMovies.length,
      similarMovies: detailedMovies,
    });
  } catch (error: any) {
    console.error("‚ùå Error in getSimilarMovies:", error);

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get similar movies",
        type: "INTERNAL_ERROR",
      });
    }
  }
});

export {
  GetTrendingMovies,
  GetMovieData,
  saveCommentToMovie,
  deleteCommentFromMovie,
  GetMovieReviews,
  getSimilarMovies,
};
