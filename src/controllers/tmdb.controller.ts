import admin, { db } from "../config/firebase.config.js";
import Scraper from "../data/scrape.js";
import { ApiError } from "../utils/ApiError.utils.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import type { Request, Response } from "express";
import {
  GetMovieByTitleFunction,
  isOMDbError,
  type OMDbDetailResponse,
} from "./omdb.controller.js";
import { getRecommendationsFromML } from "./user.controller.js";

interface IMDBTrendingResponse {
  title: string;
  movieUrl: string;
  watchlistId: string;
  year: string;
  posterUrl: string;
  posterAlt: string;
  metascore: string;
  imdbVotes: string;
  imdbRating: string;
  rating: string;
  runtime: string;
  ranking: string;
  plot: string;
  director: string;
  stars: string[];
}

interface CachedTrendingMovies {
  data: IMDBTrendingResponse[];
  cached_at: admin.firestore.Timestamp;
  auto_generated: boolean;
}

const fetchTrendingMoviesFromAPI = async (): Promise<
  IMDBTrendingResponse[]
> => {
  try {
    const scraper = new Scraper();
    const movieList = await scraper.scrapeTrending(
      "https://www.imdb.com/list/ls082250769/"
    );

    const data = movieList as IMDBTrendingResponse[];

    if (!Array.isArray(data) || data.length === 0) {
      throw new ApiError(500, "No trending movies data received");
    }

    return data;
  } catch (error) {
    console.error("Error fetching trending movies:", error);
    throw new ApiError(500, "Failed to fetch trending movies");
  }
};

const storeTrendingMoviesInCache = async (
  data: IMDBTrendingResponse[],
  autoGenerated = false
): Promise<void> => {
  try {
    const now = admin.firestore.Timestamp.now();

    const cacheData: CachedTrendingMovies = {
      data,
      cached_at: now,
      auto_generated: autoGenerated,
    };

    await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .set(cacheData);

    console.log(
      `Stored trending movies in cache (${
        autoGenerated ? "auto-generated" : "manual"
      }):`,
      new Date().toISOString(),
      `- Total movies: ${data.length}`
    );
  } catch (error) {
    console.error("Error storing cache:", error);
    throw new ApiError(500, "Failed to store cache");
  }
};

const GetTrendingMovies = asyncHandler(async (req: Request, res: Response) => {
  try {
    const cacheDoc = await db
      .collection("trending_movies_cache")
      .doc("daily_trending")
      .get();

    if (cacheDoc.exists) {
      const cachedData = cacheDoc.data() as CachedTrendingMovies;
      return res.status(200).json({
        success: true,
        data: cachedData.data,
        source: "cache",
        cached_at: cachedData.cached_at.toDate(),

        total_movies: cachedData.data.length,
      });
    }

    console.log("Fetching trending movies from IMDb");
    const trendingData = await fetchTrendingMoviesFromAPI();
    await storeTrendingMoviesInCache(trendingData, false);

    res.status(200).json({
      success: true,
      data: trendingData,
      source: "api",
      cached_at: new Date(),
      total_movies: trendingData.length,
    });
  } catch (error: any) {
    console.error(" Error getting trending movies:", error);

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get trending movies",
        type: "INTERNAL_ERROR",
      });
    }
  }
});

const fetchMovieFromIMDb = async (imdbId: string): Promise<any> => {
  try {
    const scraper = new Scraper();
    const movieData = await scraper.scrapeCompleteMovieData(
      `https://www.imdb.com/title/${imdbId}`
    );

    if (!movieData) {
      throw new ApiError(404, "Movie not found or failed to scrape");
    }

    return movieData;
  } catch (error) {
    console.error("Error scraping movie data:", error);
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, "Failed to scrape movie data from IMDb");
  }
};

const storeMovieDataInFirebase = async (
  imdbId: string,
  movieData: any
): Promise<void> => {
  try {
    const movieDoc = {
      imdb_id: imdbId,
      data: movieData,
      created_at: admin.firestore.Timestamp.now(),
      updated_at: admin.firestore.Timestamp.now(),
    };

    await db.collection("movies").doc(imdbId).set(movieDoc);

    console.log(`stored movie data for ${imdbId} in Firebase`);
  } catch (error) {
    console.error("Error storing movie data in Firebase:", error);
    throw new ApiError(500, "Failed to store movie data in Firebase");
  }
};

const GetMovieData = asyncHandler(async (req: Request, res: Response) => {
  try {
    const imdbIdParam = req.params.imdbId;
    if (!imdbIdParam) {
      throw new ApiError(400, "IMDb ID parameter is required");
    }

    const movieDoc = await db.collection("movies").doc(imdbIdParam).get();

    if (movieDoc.exists) {
      const movieData = movieDoc.data();
      console.log(`ðŸ“‹ Retrieved movie data for ${imdbIdParam} from Firebase`);

      return res.status(200).json({
        success: true,
        imdb_id: imdbIdParam,
        data: movieData?.data,
        source: "firebase",
      });
    }

    console.log(`Scraping movie data for ${imdbIdParam} from IMDb...`);
    const apiKey = process.env.OMDB_API_KEY;

    const url = `https://www.omdbapi.com/?i=${imdbIdParam}&apikey=${apiKey}`;

    const movieData = await fetchMovieFromIMDb(imdbIdParam);
    const response = await fetch(url);
    const data = (await response.json()) as OMDbDetailResponse;
    if (isOMDbError(data)) {
      throw new ApiError(404, data.Error, "NOT_FOUND");
    }
    const omdbRating = data.Ratings;
    const storyLine = data.Plot;
    const genre = data.Genre;
    const BoxOffice = data.BoxOffice;
    const Language = data.Language;
    const title = data.Title;
    const Released = data.Released;
    const Runtime = data.Runtime;
    const Awards = data.Awards;
    const Director = data.Director;
    const Rated = data.Rated;
    const Country = data.Country;

    movieData.Country = Country;
    movieData.Director = Director;
    movieData.Released = Released;
    movieData.Runtime = Runtime;
    movieData.Awards = Awards;
    movieData.Language = Language;
    movieData.storyLine = storyLine;
    movieData.rating = omdbRating;
    movieData.genre = genre;
    movieData.BoxOffice = BoxOffice;
    movieData.title = title;
    movieData.Rated = Rated;

    await storeMovieDataInFirebase(imdbIdParam, movieData);
    console.log("movieData", movieData);
    res.status(200).json({
      success: true,
      imdb_id: imdbIdParam,
      data: movieData,
      source: "scraper",
    });
  } catch (error: any) {
    console.error(` Error getting movie data for :`, error);

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get movie data",
      });
    }
  }
});

const saveCommentToMovie = async (
  imdbId: string,
  commentData: {
    movieTitle: string;
    poster: string;
    imdb_id: string;
    userId: string;
    userDisplayName: string;
    userPhotoURL?: string;
    comment: string;
    rating?: number;
    title: string;
  }
): Promise<void> => {
  try {
    const commentId = `${commentData.userId}_${imdbId}`;
    const timestamp = new Date().toISOString();

    const movieComment = {
      id: commentId,
      movieTitle: commentData.movieTitle,
      poster: commentData.poster,
      userId: commentData.userId,
      userDisplayName: commentData.userDisplayName,
      userPhotoURL: commentData.userPhotoURL,
      comment: commentData.comment,
      rating: commentData.rating,
      title: commentData.title,
      imdb_id: commentData.imdb_id,
      timestamp,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    };
    await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .doc(commentId)
      .set(movieComment, { merge: true });

    console.log(`Comment saved for movie ${imdbId}`);
  } catch (error) {
    console.error("Error saving comment to movie:", error);
    throw new ApiError(500, "Failed to save comment to movie");
  }
};
const deleteCommentFromMovie = async (
  imdbId: string,
  userId: string
): Promise<void> => {
  try {
    const commentId = `${userId}_${imdbId}`;

    const commentDoc = await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .doc(commentId)
      .get();

    if (!commentDoc.exists) {
      console.log(`Comment ${commentId} not found in movie ${imdbId}`);
      return;
    }

    await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .doc(commentId)
      .delete();

    console.log(`Comment deleted from movie ${imdbId}`);
  } catch (error) {
    console.error("Error deleting comment from movie:", error);
    throw new ApiError(500, "Failed to delete comment from movie");
  }
};
const GetMovieReviews = asyncHandler(async (req: Request, res: Response) => {
  try {
    const { imdbId } = req.params;

    if (!imdbId) {
      throw new ApiError(400, "IMDb ID is required", "BAD_REQUEST");
    }

    const reviewsSnapshot = await db
      .collection("movies")
      .doc(imdbId)
      .collection("comments")
      .orderBy("timestamp", "desc")
      .get();

    const reviews = reviewsSnapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));
    res.status(200).json({
      success: true,
      data: reviews,
      total_reviews: reviews.length,
      imdb_id: imdbId,
    });
  } catch (error: any) {
    console.error("Error getting movie reviews:", error);

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get movie reviews",
        type: "INTERNAL_ERROR",
      });
    }
  }
});
const getSimilarMovies = asyncHandler(async (req: Request, res: Response) => {
  try {
    const { title } = req.params;
    //@ts-ignore

    const userId = req.user?.uid;
    console.log("sdfsdhfdsjhfsd");
    if (!title || title.trim() === "") {
      throw new ApiError(404, "Title parameter is required", "NOT_FOUND");
    }
    const detailedMovies = [];

    const similarMovies = await getRecommendationsFromML(title);
    for (const movie of similarMovies) {
      const detailMovie = await GetMovieByTitleFunction(userId, movie);
      detailedMovies.push(detailMovie);
    }
    res.send({
      success: true,
      message: "similarMovies processed successfully",
      similarMoviesCount: detailedMovies.length,
      similarMovies: detailedMovies,
    });
  } catch (error) {
    console.log("Error has been occured on getSimilarMovies");

    if (error instanceof ApiError) {
      res.status(error.statusCode).json({
        success: false,
        status: error.statusCode,
        message: error.message,
        type: error.type,
      });
    } else {
      res.status(500).json({
        success: false,
        status: 500,
        message: "Failed to get movie reviews",
        type: "INTERNAL_ERROR",
      });
    }
  }
});
export {
  GetTrendingMovies,
  GetMovieData,
  saveCommentToMovie,
  deleteCommentFromMovie,
  GetMovieReviews,
  getSimilarMovies,
};
